# ЗАВЕРШИМОСТЬ

Заметим, что в исходной системе есть цикл. Действительно: 

- `bababb -> bbabb` (правило `ababb -> babb`)
- `bbabb -> baababb` (правило `bba -> baaba`)
- `baababb -> bababb` (правило `ababb -> babb`)

Поэтому система **НЕ ЗАВЕРШИМА**.

Сделаем другую систему, которая будет завершимой. Для этого выберем фундированный порядок: 
- В случае, если длины строк различны, то считаем, что больший порядок имеет строка с меньшей длиной. 
- В случае, если длины строк совпадают, то больший порядок будет иметь строка, которая больше лексикографически. 

В связи с выбранным порядком, изменим в двух правилах левую и правую часть:
baaba -> bba
baabb -> bbb


# ЛОКАЛЬНАЯ КОНФЛЮЭНТНОСТЬ

Заметим, что локальная конфлюэнтность отсутствует. Действительно, рассмотрим строку `bbbaab`. К ней можно применить 2 правила:

- `bbba -> ba` 
- `bbaab -> baa`

Если применяем правило `bbba -> ba`, то получаем строку `baab`. Заметим, что к ней больше нельзя применить никаких правил.

Теперь применим правило `bbaab -> baa`. Получим строку `bbaa`. Заметим, что к ней больше нельзя применить никаких правил.

Поэтому локальная конфлюэнтность отсутствует.

Напишем код алгоритма пополнения Кнута Бендикса. В итоге получим, что пополненная система содержит правила:

aaaa -> a
aaab -> b
bbba -> ba
bbbb -> bb
ababb -> babb
baaba -> bba
baabb -> bbb
bbaaa -> baab
bbaab -> baa
bbabb -> abab
baba -> baa
babbaa -> babba
babbab -> abb
babba -> bb
babb -> bab
bab -> abb
baaa -> abb
abaa -> baa
baa -> abb
abbb -> abb
abb -> bb
bba -> bb
bb -> ba
aba -> ba

# КОНЕЧНОСТЬ

Заметим, что в полученной системе будет 8 нормальных форм: 
ε, a, b, aa, ab, ba, aaa, aab


К любой другой строке можно применить какое-то правило.

# МИНИМИЗАЦИЯ

Теперь воспользуемся ещё таким свойством. Пусть есть правила `s1 -> s2`, `s1 -> s3`. Тогда если порядок `s2` больше, чем порядок `s3`, то можно убрать правило `s1 -> s3` и добавить правило `s2 -> s3`.

После применения свойства получим такие правила:
aaaa -> a
aaab -> b
aaaba -> babb
baba -> baab
bab -> baa
babbb -> babba
aaba -> baa
baa -> abb
aba -> bb
bb -> ba


# ФАЗЗ-ТЕСТИРОВАНИЕ

Возьмём произвольную строку `s1` и в исходной системе `T` применим к ней произвольную последовательность правил, получим строку `s2`. Если в системе `T'` строки `s1` и `s2` сводятся к одной строке, то всё правильно.

# МЕТАМОРФНОЕ ТЕСТИРОВАНИЕ

Заметим, что в исходной системе `T` есть такие инварианты:

1. **Если в слове есть буква `b`, то она ни при любом правиле в слове всё равно останется буква `b`.**

   Тестирование показало, что этот инвариант также выполняется и в новой системе `T'`.

2. **Число букв `b` не увеличивается при каждом правиле в исходной системе.**

   Тестирование показало, что этот инвариант **не выполняется** в новой системе `T'`. Это даже понятно по правилу `baa -> abb` в новой системе `T'`.